---
title: "Fan-In/Fan-Out"
description: "Details about fan-in/fan-out in workflows"
---

# Fan-In/Fan-out (Parallelism) Pattern

One of the most powerful features of workflows is the ability to run tasks in parallel. The fan-in/fan-out pattern allows you to emit multiple events simultaneously and process them concurrently, then aggregate the results. 

This works by: 

1. **Emitting multiple events** to be processed in parallel
2. **Collecting results** as they come in
3. **Completing** once all parallel tasks are finished

In order to implement the fan-in/fan-out pattern, we can follow these steps:

**1. Define events and workflow**

First, we define the events that will flow through our workflow:

```ts
import {
  createWorkflow,
  workflowEvent,
} from "@llamaindex/workflow-core";

// Define the events we'll use
const startEvent = workflowEvent<string>();      // Triggers the fan-out process
const processItemEvent = workflowEvent<number>(); // Individual items to process
const resultEvent = workflowEvent<string>();     // Results from processed items
const completeEvent = workflowEvent<string[]>(); // Final aggregated results
```

Next, we create our workflow and set up tracking variables:

```javascript
const workflow = createWorkflow();

// Shared variables to track progress
let itemsToProcess = 10; // Total number of items to process
let itemsProcessed = 0;  // Counter for completed items
```

**2. Create the fan-out handler**

This handler receives the start event and fans out multiple processing tasks:

```ts
workflow.handle([startEvent], async (context, start) => {
  const { sendEvent, stream } = context;
  itemsProcessed = 0; // Reset counter for this execution
  
  // Fan out: emit multiple events to be processed in parallel
  for (let i = 0; i < itemsToProcess; i++) {
    sendEvent(processItemEvent.with(i));
  }
  
  // Collect results as they complete
  try {
    const results = await stream
      .filter(resultEvent)                           // Only listen for result events
      .until(() => itemsProcessed === itemsToProcess) // Stop when all items are done
      .toArray();                                    // Collect into an array
    
    // Send the final aggregated result
    sendEvent(completeEvent.with(results.map((event) => event.data)));
  } catch (err) {
    console.error("Error processing items:", err);
  }
});
```

The for loop emits all processItemEvent events in parallel, enabling concurrent processing. Results are collected as they arrive using `stream.filter().until().toArray()`, with the `until()` condition ensuring that processing continues until all items have been handled. This approach is non-blocking, as the handler completes immediately after initiating the parallel processing.

**3. The processing handler**

This handler processes each individual item:

```ts
workflow.handle([processItemEvent], async (event) => {
  // Simulate some async work (like API calls, database operations, etc.)
  await new Promise((resolve) => setTimeout(resolve, Math.random() * 100));
  
  // Process the item
  const processedValue = `Processed: ${event.data}`;
  
  // Update the shared counter after processing completes
  itemsProcessed++;
  
  // Return the result event
  return resultEvent.with(processedValue);
});
```

Each item is processed independently and can perform asynchronous operations, such as API calls or database queries. Because a random delay is introduced for each item, they complete at different times, demonstrating true parallelism. After processing, the shared counter `itemsProcessed` is incremented to track progress, and a `resultEvent` is emitted with the processed data. This ensures that results are collected as soon as each item finishes, enabling efficient aggregation and real-time monitoring of workflow progress.

**4. Running the Workflow**

Here's how to execute the fan-in/fan-out workflow and observe the results:

```ts
async function runFanOut() {
  console.log("Running fan-out");
  const { stream, sendEvent } = workflow.createContext();
  
  // Start the fan-out process
  sendEvent(startEvent.with("Start fan-out"));
  
  // Listen to all events as they occur
  for await (const event of stream) {
    if (processItemEvent.include(event)) {
      console.log(`Processing item: ${event.data}`);
    } else if (resultEvent.include(event)) {
      console.log(`Result received: ${event.data}`);
    } else if (completeEvent.include(event)) {
      console.log("Final aggregated results:", event.data);
      break; // All done!
    }
  }
}

runFanOut();
```